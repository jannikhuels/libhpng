PARSER_BEGIN(SMCParser)

/** Simple brace matcher. */
public class SMCParser {

  /** Main entry point. */
  public static void main(String args[]) throws ParseException {
    SMCParser parser = new SMCParser(System.in);
    SimpleNode root = parser.Input();
    root.dump("");
  }

}

PARSER_END(SMCParser)

SKIP :
{
  " "
| "\t"
}

TOKEN :
{
  <LBRACE: "(">
| <RBRACE: ")">
| <DIGITS: (["0"-"9"])+>
| <NUMBER: <DIGITS> "." <DIGITS>>
| <ID: "'"(((["a"-"z","A"-"Z"])+) | (<DIGITS>))+ "'">
| <SEP: ",">
| <NOT: "!">
| <OR: "OR">
| <AND: "AND">
| <UNTIL: "U">
| <PROB: "P">
| <COMPARE: "<" | ">" | "=" | "<=" | ">=">
| <FLUID: "fluidlevel">
| <TOKENS: "tokens">
| <ENABLED: "enabled">
| <CLOCK: "clock">
| <FIRINGS: "firings">
| <DRIFT: "drift">
| <UBOUND: "uboundary">
| <LBOUND: "lboundary">
| <ARC: "condition">
| <EOL:  "\n" | "\r" | "\r\n" >
}


SimpleNode Input() #ROOT:
{}
{
   Psi()<EOL>{return jjtThis;}
}

void Psi() #void :
{Token t;}
{
 <LBRACE> Psi() <RBRACE> | Prob() | And() | Or() | Until() | Not() | Atomic()
}

void Atomic() #void:
{}
{
  Fluid() | Tokens() | Enabled() | Clock() | Firings() | Drift() | Ubound() | Lbound() | Arc()
}

void Not() #NOT:
{}
{
    <NOT> Psi() 
}

void And() #AND:
{}
{
   <AND> <LBRACE> Psi() <SEP> Psi() <RBRACE>
}

void Or() #OR:
{}
{
   <OR> <LBRACE> Psi() <SEP> Psi() <RBRACE>
}

void Until() #UNTIL:
{}
{
   <UNTIL> "_" Double() <LBRACE> Psi() <SEP> Psi() <RBRACE>
}

void Prob() #PROB:
{}
{
   <PROB> Compare() Double() <LBRACE> Psi() <RBRACE>
}

void Double() #DOUBLE:
{Token t;}
{
  t= <NUMBER> {jjtThis.value = t.image;}
}

void Integer() #INTEGER:
{Token t;}
{
  t=<DIGITS> {jjtThis.value = t.image;}
}

void Compare() #COMPARE:
{Token t;}
{
  t=<COMPARE> {jjtThis.value = t.image;}
}

void Id() #ID:
{Token t;}
{
  t=<ID> {jjtThis.value = t.image;}
}

void Fluid() #ATOMIC_FLUID:
{}
{
  <FLUID> <LBRACE> Id() <RBRACE> Compare() Double()
}

void Tokens() #ATOMIC_TOKENS:
{}
{
  <TOKENS> <LBRACE> Id() <RBRACE> Compare() Integer()
}

void Enabled() #ATOMIC_ENABLED:
{}
{
  <ENABLED> <LBRACE> Id() <RBRACE>
}

void Clock() #ATOMIC_CLOCK:
{}
{
  <CLOCK> <LBRACE> Id() <RBRACE> Compare() Double()
}

void Firings() #ATOMIC_FIRINGS:
{}
{
  <FIRINGS> <LBRACE> Id() <RBRACE> Compare() Integer()
}
 
void Drift() #ATOMIC_DRIFT:
{}
{
  <DRIFT> <LBRACE> Id() <RBRACE> Compare() Double()
}

void Ubound() #ATOMIC_UBOUND:
{}
{
  <UBOUND> <LBRACE> Id() <RBRACE>
}

void Lbound() #ATOMIC_LBOUND:
{}
{
  <LBOUND> <LBRACE> Id() <RBRACE>
}

void Arc() #ATOMIC_ARC:
{}
{
  <ARC> <LBRACE> Id() <RBRACE>
}
